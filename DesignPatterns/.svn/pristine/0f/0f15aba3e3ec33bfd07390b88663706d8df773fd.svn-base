package com.eclipse.patterns;

/**
 * The State pattern is used when you want to have an enclosing class
switch between a number of related contained classes, and pass method calls
on to the current contained class. Design Patterns suggests that the State
pattern switches between internal classes in such a way that the enclosing
object appears to change its class. In Java, at least, this is a bit of an
exaggeration, but the actual purpose to which the classes are put can change
significantly.

1. The State pattern localizes state-specific behavior in an individual class
for each state, and puts all the behavior for that state in a single object.
2. It eliminates the necessity for a set of long, look-alike conditional
statements scattered through the program¡¯s code.
3. It makes transition explicit. Rather than having a constant that specifies
which state the program is in, and that may not always be checked
correctly, this makes the change explicit by copying one of the states to
the state variable.
4. State objects can be shared if they have no instance variables. Here only
the Fill object has instance variables, and that color could easily be made
an argument instead.
5. This approach generates a number of small class objects, but in the
process, simplifies and clarifies the program.
6. In Java, all of the States must inherit from a common base class, and they
must all have common methods, although some of those methods can be
empty. In other languages, the states can be implemented by function
pointers with much less type checking, and, of course, greater chance of
error.
 * */

public class State {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

}
